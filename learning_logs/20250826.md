# color/ image 웹페이지 꾸미기
## 배경 꾸미기
### 배경에 그라데이션 넣기
- 그라데이션 : 2가지 이상의 색을 이용하여 두 색을 점점 변화시켜 가며 채색되는 방식(웹사이트에서 흔히 사용되는 않습니다.)

https://showcases.yalco.kr/html-css/02-08/02.html
1. background 속성의 속성 값으로 linear-gradient(색1,색2)
2. linear-gradient(각도,색1,색2)
  - 참고 : deg -> degree
3. linear-gradient(각도,색1,퍼센트값,색2)
  - 이전까지는 색상이 반반씩 나왔으나. 첫번째 색의 구간을 지정하는 방식으로 퍼센트값을 넣어줌
4. linear-gradient(색1,색2,색3)
  - 참고 : linear-gradient(색1 퍼센트값, 섹2 퍼센트값2, 색3 퍼센트값)

  11_gradient 실습

## 포지셔닝
HTML로 작성한 문서는 하나의 기기로만 여는 것이 아니기에 상대적입니다. 따라서 요소의 위치를 잡는데 포지셔닝이 매우 중요한 역할을 합니다. 그것의 기초가 저희가 이전 수업에서 배웠던 `<span> `,`<div>`의 성격차이입니다. 그리고 어제 display : inline/ block/ inline-block을 배웠었습니다
### position 속성
참조
https://showcases.yalco.kr/html-css/02-09/01.html

12_position 실습

- 특정 HTML 요소들이 해당 페이지에서 어떻게 배치될지 설정하는 데 사용
- `position 속성은 부모 요소의 것이기 때문에, 자식에 되물림 되지 않음` -> yellow의 position속성이 red로 이어지지 않음을 뜻함

1. static
  - position 속성의 default 값으로 top/ left 등의 위치 조정을 하더라도 위치 이동 x ->  HTML 구조를 따르는 것
2. ralative
  - 상대적인, 이라는 의미로 위치 이동이 가능
  - 자신의 HTML 구조 상에서의 위치에서 이동하게 됩니다.
  - 해당 요소의 위치가 이동하지만 요소가 차지하는 공백은 그대로 유지가 됨.
    -> 그 결과 가장 상위의 div 범위를 아에 벗어난다고 하더라도 6번 div가 5번 div자리로 이동하지 않음
3. absolute
  - 절대적인, 이라는 뜻으로 `첫 부모 요소(statoc이 아닌 상태로 만나는 상위 html 구조)`의 속성값을 이용하여 위치 이동이 가능(relative랑은 다른 좌표가 필요)
  - 이상의 경우는 또 relative와 달리 공백 요소를 고정하지 않고, 첫 부모의 좌표를 따라서 움직이기 때문에 공백이 생기게 될 경우 다음 div이 위치이동을 하는 것을 볼 수 있습니다. 위치이동이 일어나는 이유는, display: ineline-block 때문입니다.
  - 그래서 .yellow가 static인 상태로 .red를 position: absoulte; top: 100px; left:100px로 잡을 경우 .yellow가 `첫 부모가 아니기 때문에`, 그상위인 .outer가 첫 부모 요소가 되고, 때문에 회식 borderline을 가진 div기준으로 아래로 100px, 오른쪽으로 100px 이동한 위치가 됩니다
  - .yellow의 position을 relative로 잡게 되면, 첫 부모 요소가 되기 때문에, 노란색 div 기준으로 아래쪽으로 100px, 우측100px 이동한 위치로, .red가 이동하게 됩니다.

4. fixed
  - 고정된, 이라는 의미로 부모 요소가 아니라 뷰포트viewpoer를 기준으로 위치를 지정함. 그래서 outer보다 더 위에 있는 브라우저의 흰색 부분을 기준으로 하기 때문에, 똑같이 .red를 top:100px left:100px를 적용한다하더라도위치가 위/왼쪼긍로 이동하는 겁니다.
  - 뷰포트에 `고정된` 위치를 사용하기 때문에, 브라우저의 스크롤링에 영향을 받지 않습니다.
    - 해당 속성을 사용할 경우, 특정 팝업창에 띄웠을 때 스크롤과 상관없이 한 곳에 고정시킬 떄 자주 사용하는 속성입니다.

5. sticky
  - 특정 요소가 스크롤로 이동할 수 있는 공간을 top/ bottom / left/ right / z-index 속성값을 이용하여 지정이 가능.
  - 예를 들어 홈페이지에서 nav에 해당하는 부분이 일정 수준까지는 아래로 스크롤링 하였을 때 따라내려오는데, 그 부분이 지나게 되면 따라오지 않는 등의 효과를 줄때 사용함.

  -부모 요소의 여백에 영향을 받음. 자식 요소의 위치를 고정하더라도 스크롤하면서, 부모 요소의 위치를 벗어난다면, 자식 요소는 그 이상 움직이지 못함. 이상의 이유로 sticky는 부모 요소의 안쪽이 아니라 동등/ 바깥쪽 요소에 지정하는 것이 좋습니다.

### z-index 속성

https://showcases.yalco.kr/html-css/02-09/02.html 참조

- static이 아닌 모든 경우에 각 요소들 간에 높이 차이를 주게 됨으로 요소들간의 배치를 요흉적으로 하기 위한 값
- 겹쳐지는 순서를 인위적으로 바꾸고자 할 때 사용
- z-index의 default 값은 auto로 설정되어있는데 이는 0을 의미
- 0보다 큰 값을 지니고 있다면 상위로 올라가게 됨
- 이상의 이유로 광고창 등의 경우 무조건 상위에 있어야 하기 때문에 css 파일을 확인해보시면, z-index의 값이 999 같은것도 구경이 가능함.

13_zindex.html /css 

# flex 레이아웃
- 모든 웹사이트는 큰 레이아웃 형태의 구조로 되어있고, 이 레이아웃을 만드는 방법은 다양합니다. 예전에는 HTML 테이블 구조와 블록/인라인의 조합으로 사이트 구조를 만들어야 했습니다만, 오늘날 flex 가 나오면서 각종 css 기능을 통해 레이아웃을 설정하게 되었습니다.

### 부모에 적용한 flex
https://showcases.yalco.kr/html-css/02-11/01.html 참조

- 참고 : 부모에 적용하는 속성이라는 것은 부모 관련 css에 작성한다는 뜻으로 사용합니다.

참조 사이트를 기준으로 할 때, 바깥족 div에 display: flex;를 적용했을 때와 display: inline-flex;를 적용했을 때의 p 태그 위치가 바뀌는점이 확인이 가능

이상의 차이에서 확인 할 수 있는 점 :
  1. display : flex;를 div에 적용시킬 경우, blck 성질은 그래도 유지한 상태로 flex가 적용됨
    -그래서 p 태그가 개행된 형태로 출력
  2. display : inline-fex;를 div에 적용시킬 경우, block 성질이 inline으로 바뀌게 되면서 회색 div영역 이후 부분에 p 태그의 텍스트가 출력이됩니다.

## 각 속성들
1. flex-direction 속성
- 내부의 자식 요소들을 어느 축을 기준으로 정렬할지 결정
- default 값은 row(왼쪽부터 차례대로 정랼) -> 자식 요소들을 row로 정렬하기에 참조사이트 기준 1,2,3, div 가 세로로 길게 출력이 됩니다.

2. jstify-content
  - 메인 축에서 내부 요소를 정렬하는 결정
  - default 값은 flex-row : 왼쪽부터 내부 요소 정렬
  - center : 텍스트 중앙 정렬하는 것처럼 내부 요소들을 중앙에 배치
  - flex-end : 메인 축의 끝 부분인 오른쪽으로 내부 요소가 정렬됨. 순서는 flex-direction을 따릅니다.
  - space-between : 맨왼쪽과 오른쪽에 하나씩 배치를 시키고, 그 사이에 나머지 요소들을 균등하게 배치
  - spcae-around : 모든 빈공간의 크기를 균등하게 분배

3. align-items : flex의 메인 축에서의 반대편 축에서(flex-directin: row라면 y축 방향으로, flex-direction: column; 이라면 x축방향으로) 내부 요소를 정렬하는 방식을 결정함
  -() 내부의 내용을 토대로 flex-direction: row; 라면 반대 방향인 세로 방향으로 stretch가 일어나서 세로로 긴 div가 3개 생겼다고 볼 수 있음
  - stretch : align-items 의 default값으로 이상의 설명처럼 길게 늘립니다.
  - flex-start : min-width/ min-height의 크기 그대로 정렬하는위치를 왼쪽 상단으로 시작함.
  - center : 중앙정렬
  - flex-end : 수직 축의 끝 부분인 아래로 정렬

- 참고 : display:flex / flex-direction/ aligh-items는 대부분 세트로 같이 돌아다니기에, 여러 사이트에서 이리저리 움직여보고 css 값을 넣어보는 것도 좋은 방법

4. flex-wrap
  - 내부 요소들이 자식 요소의 영역을 넘어가는 부분을 전제로 배치 방식을 자동으로 바꿔주는 속성값
  - default 값 : no-wrap
  - wrap으로 설정하게 되면 내부 요소가 부모 요소를 넘어가지 않도록 줄바꿈이 일어남. 주로 컨텐츠가 한 줄이 아니라, 여러줄일 때 사용
  - 페이지 상에서의 효과를 보면 min-width/ min-height 를 가지고 있는 상태에서 최대한 stretch가 적용되어 부모 div영역을 차지하는 것을 확인 할 수 있습니다. 만약에 그게 보기 싫을 경우 stretch를 flex-start/ center/ flex-end로 바꾸면 됩니다.

5. align-content
  align-items 와 혼동이 일어나기 쉽습니다. align-item의 경우에는 flex-start/center/flex-end를 적용 시킬 경우 가운데 여백이 같은 크기의 공백으로 나뉘어진 상태에서 내부 요소가 위/ 중간/ 아래에서 정렬이 일어납니다. 그래서 첫째줄과 둘째줄 사이에 공백이 있습니다.
    - 반면에 align-content를 사용할 경우, 1번~12번 div가 하나의 묶으로 공백없이 정렬된 상태에서 위/중간/아래에 정렬이 일어납니다.

6. gap - 내부 요소들 사이에 들어가는 공백의 크기를 지정(즉 자식 div에 margin을 적용하는것과 혼동하기 쉽습니다.)

### 자식에게 적용하는 flex

https://showcases.yalco.kr/html-css/02-11/02.html 참조

1. flex-basis / flex-shrink
  - 자식에 flex 관련 속성을 사용하기 위해서는 부모의 css에 `display:flex;` 가 적용되어야합니다. 그리고 아까 위에서 언급한 것 처럼, 세트인 `flex-direction`을 적용해야합니다. 이제 설명하는 부분은 flex-direction:row;를 기준으로 합니다.

  - `부모 요소에서 flex-direction:row;`이므로, 자식 요소에서의 flex-basis는 row방양으로의 크기를 정합니다.
  - default 값은 auto
  - 절대값 / 상대값을 지정할 수 있습니다.

  - 만약에 자식 요소의 flex-basis 를 절대값으로 잡는 바람에 부모 요소의 크기를 거기에 맞춰서 강제로 증가시키게 된다면 반응형 페이지라고 할 수 없습니다. 
  - 해당 경우에 사용하는 것이 flex-shrink입니다.
  - fefault 값 : 1
    - 전체공간이 부족할 경우 해당 내부 요소으,ㅣ 크기가 컨텐츠(여기서는 주황색 div)의 width또는 flex-basis의 최대 크기가 부모 요소를 넘어가지 못하도록 강제하는 값

2. flex-grow
  - default 값 : 0 - 기존의 크기를 그대로 유지함
  - 숫자의 크기에 따라 나머지 형제 요소들의 공백 크기의 곱만큼 자기가 커집니다.(커지는 방향은 부모의 flex-direction 설정값에 따릅니다.)

## 요소를 감추는 방법
1. 원래 보이던 요소를 투명하게 만드는 방법
2. 요소가 보이지 않으면서, 가지고 있는 기능 자체도 날리는 방법

### CSS에서 요소를 숨기는 3가지 방법
1. opactiy 속성 이용
  - 불투명도를 뜻하며 범위는 0~1 사이의 값. 0으로 하면 불투명도는 0이기에 투명해짐
  - 해당 요소를 투명하게 만드는 것이기 때문에 기능은 작동함
  - 예전에 악성 광고 사이트에서 많이 쓰던 방법인데, 광고팝업을 oapcity를 0으로 설정하여 클릭시, 광고페이지로 넘어가게 하는 방식
2. visibility 속성 활용
  - visibility 속성 값 : visible / hidden 2가지로, hidden의 경우에 숨겨줌
  - 기능도 사라짐
  - 그런데 공백은 남아있습니다. 보이냐 안보이냐만 지정했기 때문에 그냥 안보이는 상태
3. display 속성 활용
  - 얘는 많은 속성값이 존재합니다.
  - flex
  - block
  - inline
  - inline-block
  - 참조사이트에는 div가 일열로 나열되어야 했기에 inline-block만 나왔음
  - 그리고 none을 사용시
    - 눈에 안보이며/ 기능은 삭제 / 아에 없는 것이 되기 때문에 뒤에 있던 div가 앞으로 밀려오는 것 까지 확인이 가능합니다.

참조
https://showcases.yalco.kr/html-css/02-10/02.html

# CSS 고급 기능
## 반복 및 공통되는 스타일
- CSS에서 사용하다보면 여러 페이지에서 같은 코드를 반복해서 사용하는 일이 생깁니다. CSS에서 공통적으로 사용되는 코드를 `모듈화`하여 다른 CSS 파일로 임포트 하는 방법. 그리고 자주 사용하는 속성값을 변수명으로 지정하는 방법

### 다른 CSS 파일을 업로드하기
형식:
  `@import url(불러올 파일 경로)`

ch_07applied_style
01_cssimport.html / 01.cssimport.css / 00_shared.css
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cssimport</title>
  <link rel ="stylesheet" href="./01_cssimport.css">
</head>
<body>
  <h1>다른 CSS 파일 import 하기</h1>
  <p>
    <strong>@import</strong>를 사용하면 절대 및 상대 경로를 사용하여 <br> 다른 CSS 파일의 내용을 불러올 수 있습니다.
  </p>
  <p>
    여러 페이지에서 공통적으로 사용되는 스타일들을 특정 파일로<br>분리하여 모듈화하는 것이 가능합니다.
  </p>
  <p class="sr-only">
    이 p 태그는 import된 <i>shared.css</i>의 코드가 적용됩니다.
  </p>
</body>
</html>

```
```css
.sr-only{
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  white-space: nowrap;
  border-width: 0;
  
  /* 외부 CSS 파일 import */
@import url(./00_shared.css);

body{
  margin: 0;
  padding: 24px;
}
}

```
이상의 결과 화면을 확인 했을 때, HTML 문서상에서 .sr-only 클래스 명을 사용한 `<p>` 태그 내용이 보이지 않도록 숨겨지는 것을 확일 할 수 있습니다. 이는 특정 문단의 내용(혹은 div일수도 있습니다. class는 공유가 가능하므로)를 감추는 설정이 담긴 shared.css 파일을 `@import` 통하여 외부에서 가지고 와서 01_cssimport.css에서 사용했기 때문

이상처럼 HTML 문서를 사용시 CSS를 적용시키는 방식으로
1. inline 방식
2. internal style sheet(내부 스타일 시트)
3. linking style sheet(링킹 스타일 시트)
으로 첫 수업을 진행하였는데 이제 외부 CSS를 가지고 오는 
4. @import (임포트 방식)
을 들 수 있겠습니다.

상황에 따라서 선택 가능합니다.
  - 변수(variable) : 특정한 데이터에 이름을 붙이는 것을 의미

예를 들어, .html을 생성할 때마다 body 테그 내애 bgcolor를 이용하여 집어넣었습니다. 이럴 경우는 쉬우니까 할만하지만, 크림슨바이올렛과 같은 hex값을 여러분들이 외우고 있다가 이후 물어보면 대답하기가 곤란함. -> 값하나만 틀려도 다른색이 튀어나오기 때문에 기억하기 쉬운 이름, 즉 변수를 붙이면 사용하기가 편리해짐 

- CSS에서 변수를 나타낼 때는 원하는 변수명을 지정하고, 그앞에 `--`를 입력하여 변수임을 표시합니다. 예를들어 디자이너와 프론트핸드 개발자 간에 소통하게 될 때 특정 색깔을 브랜드 메인 컬러로 설정했다면, `--color-main`, 그 다음 서브 컬러라면 `--color-sub1`과 같은 방식으로 지정하는 것입니다.
가장 작은 폰트 사이즈를 지정한다면, `--font-small`과 같은 방식이 될 수 있음

02_cssvariable.html /css / 00_common.css 에서 `@import url(./00_common.css)`를 통해서 _해당 파일의 변수 목록을 참조할 수 있도록 import문을 작성_ 하였습니다

그런데, i태그의 class ="not-good" / b태그의 class-wrong을 적용시 아무런 차이가 없습니다.
p태그에 공통적으로 적용한 부분만 난왔습니다.
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>css 변수 사용 법</title>
  <link rel ="stylesheet" href="./02_cssvariable.css">
</head>
<body>
  <h1>제목 부분입니다.</h1>
  <p>
    <u class="not-good">
      u태그의 not good을 적용한 부분입니다
    </u>
    <br>
    <u class ="wrong">
      u 태그의 wrong을 적용한 부분입니다.
    </u>
  </p>
  <p>
    <i class="not-good">u태그가 아닌 공통 부분을 not good을 적용한 부분입니다.</i>
    <br>
    <b class="wrong">u태그가 아닌 공통부분에 not good을 적용한 부분입니다.</b>
  </p>
</body>
</html>
```
이상의 부분만 확인시, i 태그와 u 태그의 class가 동일하기에 동잃란 css가 적용될거라고 생각하였으나, 00_common.css를 확인시, 이하를 볼 수 있듯이 u태그에서만 --not-gooe, --wrong을 참조하도록 작성되어있습니다. 즉 i태그에서는 wavy underline orange; 가 먹히지 않는다는 것입니다. 이런 css상에서의 위계 구조에 대해서도 알 필요가 있습니다.
```css

```

- :root 의미
  - 어떤 요소가 특정 태그 내에서만 사용되는 것이 아니라 페이지 전체에서 광범위하게 쓰이게 될 경우 사용하는 표현. 가상 클래스를 응용하고 root는 예약어로 전체 페이지를 의미합니다

  이상의 import문과 그 응용 그리고 CSS 변수의 개념은 특정 페이지들의 합인 웹 서비스 상에서 공통된 요소와 특정한 요소 부분을 나누어 관리하는 것은 다른 사람과의 협업 체제에서 매우 중요합니다.

## 밴더 프리팩스
1. -trasition 속성
  1. -webkit : 사파리 크롬 오페라
  2. -moz : 파이어폭스
  3. -ms : 엣지/ 익스플로어
  4. -i : 구버전 오페라

  표준이 정립되는 CSS 속성들의 경우에 각 브라우저가 구현하는대로 동작합니다. 그래서 저희는 수업시간 중에 기본앱으로 크롬을 고정하는 시간을 가졌구요. 즉 사용자마다 가능성이 있을때 벤더 프리픽스를 먼저 붙여서 사용하며, 공식 표준 속성은 맨마지막에 작성합니다.

  왜냐면 CSS는 `순서대로` 덮어쓰기 때문에, 일단 비표준으로 작성한 것이 후에 표준이 있다면 그걸로 덮어쓰기가 자동으로 이루어지기 때문이빈다

# 서체 스타일링
## 서체 및 웹 폰트(필수/ 구글 폰트 및 눈누 폰트 때문에,) 
1. chorme 구글 폰트 검색(특히 한국어로 검색하는 것이 한글 폰트가 대문에 나옵니다.)
2. 그리고 별 문제가 없다면 Noto Sans Korean 를 사용하게 되는데,
  -Noto : No Tofu를 의미합니다. 문자가 깨지는 빈 사각형 모양을 Tofu 라고 지칭하였는데, Google에서 빡쳐서 절대 안깨치는 글씨체를 만들겠다고 해서 각 국가별 Noto 시리즈가 있습니다.
  - 모든 언어를 깔끔하게 표시할 수 있는 서체.
  - 다만 이상을 이유로 너무 보편적이어서 브랜드 사용시에는 적용되지 않는 핀입니다.

03_webfont.html
# JavaScript
- 갖다놓는 의미/ 꾸미는 CSS라는 표현을 사용했습니다. 그리고 특정 범위 값의 변화 등을 시키는 역할은 JavaScript가 맡습니다.

## 발생 배경
- 지금까지 HTML/ CSS 학습을 하면서 알수 있는 점은, 그냥 클릭 했을 때 뭐가 변하는 그런 부분이 아니라, 웹 문서를 꾸미는 형태였습니다.
- JS는 웹페이지를 _동적으로_ 만들기 위해 탄생한 언어입니다. 사용자가 버튼을 누르거나, 특정 위치에서 마우스를 올리거나 하는 등의 행위를 했을 때 상호작용을 할 수 있도록 하여 UX에 엄청난 영향을 끼친 언어라고 할 수 있습니다.

## 주요 특징
1. 인터프리터 언어 : Java와 달리 Interpreter에 해당하기에 오류나기전까지는 실행은 됩니다.
2. 동적타입(Dynamically Typed) : 변수를 선언할 때 타입을 미리 지정하지 않아도 됨. 코드를 실행 중에 자기가 적당히 보고 알아서 type 을 결정합니다. Java가 초반에 선언해야하는 점과 매우 차이가 있음.
  - 이게 처음에는 편하다, 좋다하면서 쓰고 있다가보니까, 나중에 작성후 테스트 할때서야 오류가 발생하는 경우가 있어 TypeScript가 개발되기도 하였음
3. 객체기반 프로젝트(Object-based) : 클래스가 없어도 객체를 만들고 사용하는 것이 가능.
4. 싱글 스레드(Single Thread)  : 한번에 하나의 작업만 순차적으로 처리합니다. 근데 비동기 처리 개념을 통해서 복잡한 작업을 효율적으로 처리하는 것도 가능
## 장점
1. 웹 브라우저의 기본 언어(Language-HTML은 언어가 아니라고 하였음): 별도의 설치 없이 모든웹 브라우저에서 길행됩니다. (vs code 설치할 떄와 intellij 설치할때를 생각해보면 intellij때는 java 버전을 다운받았음)
2. 유연한 문법 : Java를 배운 저희에게는 너무 자유롭다 싶겠지만 이게 초심자들에게는 장점에 해당
3. 다양한 활용분야 : 웹 브라우저 외에도 서버(Node.js), 모바일 앱(React Native), 알고리즘까지 폭 넓은 분야에서 활용
4. 생태계 : NPM(Node Package Manager)이라는 패키지 저장소를 통해 수많은 오픈소스 라이브러리와 프레임워크를 활용가능합니다.
  - React는 Js의 프레임워크 중 하나입니다.
## 단점
1. 보안 : 웹브라우져에서 실행되는 만큼 보안관련 설정을 많이 해주어야합니다.(저희는 Springboot를 통해 학습 예정)
2. 느린 속도 : 옛날 이야기
3. 예측 불가능한 오류 : 아까 장점이었던, 유연한 문법에 관련된 문제로 실제로 테스트해보기 전까지는 어떤 오류가 발생할지 짐작하기 어려운 점이 있습니다. -TypeScript로 보완이 가능하지만 덕분에 저희는 TypeScript도 학습 예정
4. 브라우져 호환성 문제 : 이것도 옛날 문제이긴 하지만 ES6 이 나오고 나서는 대부분 해결되었음.

```js
console.log('Hello, JavaSript!');
```
이상에서 보면 알수 있듯, 얘는 "" 구분없이 ''얘로 등장합니다.

그래서 앞으로의 수업 코드 작성 방식 : 
HTML 태그 내에 있는 속성값의 경우에는 ""를 사용하며,
JS코드와 관련되어 있는 부분은 ''를 사용예정

근데 반대로 사용해도 실행되니까, 그럴 경우 강사의 실수라고 생각하면 좋습니다.